import { app, BrowserWindow, ipcMain, dialog, nativeImage, Tray, Clipboard, clipboard} from 'electron';
import path  from 'path';
// eslint-disable-next-line import/no-unresolved
import fs from 'fs';
import installExtension from 'electron-devtools-installer';
import { SimLoading, getHoursMinutes } from './Main/Helpers/Helpers';
import BackAgent from './Main/Agent/BackAgent';
import DbResult from './Render/Models/DbResult';
import {Result} from './Render/Models/Result';
import {ApiResult} from './Render/Models/ApiResult';
import {SummaryShift, SummaryObject} from './Render/Models/SummaryShift';
import moment from 'moment';
import bs3 from 'better-sqlite3'
import {CreateSettingsJSON,
EditSettingsJSON, ChangeSettingsJSON} from './Main/Controllers/LandingController'



// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

console.log("MAIN PRELOAD HERE: "+ MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY);

console.log("MAIN WEBPACK ENTRY: "+ MAIN_WINDOW_WEBPACK_ENTRY)

// process.windowsStore???
//process.env['ELECTRON_DISABLE_SECURITY_WARNINGS'] = 'true';
// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

const logo = nativeImage.createFromPath(path.join(__dirname,'public','icon.ico'));


 
const  createWindow = async () => {
  // Create the browser window.
//  const appIcon = new Tray(path.join(__dirname,'public','logo.png'));
const appIcon = clipboard.readImage

const logo = nativeImage.createFromPath(path.join(__dirname,'public','icon.ico'));

//const logo = nativeImage.createFromPath(path.join(__dirname,'public','logo.png'));
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    icon: logo,
    webPreferences: {
      contextIsolation: true,
      nodeIntegration: true,
     // worldSafeExecuteJavaScript: true,
      // preload.js or ts????
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      //preload: path.join(__dirname, "preload.js")
      },
    });
    
    mainWindow.setOverlayIcon(logo, 'The logo')
  
  console.log('userData path \n ',(app.getPath('userData')))
  ensureDirSync(path.join(app.getPath('userData'), 'db'));
  // and load the index.html of the app.

  console.log("\n \n "+ MAIN_WINDOW_WEBPACK_ENTRY  + "\n \n ");

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

 // if (!app.isPackaged) {
     mainWindow.webContents.openDevTools();
  //}
   
mainWindow.webContents.on('new-window', function(e, url) {
  e.preventDefault();
  require('electron').shell.openExternal(url);
});
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.



app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

function ensureDirSync (dirpath: string) {
	try {
    return fs.mkdirSync(dirpath)
	} catch (err) {
    if (err.code !== 'EEXIST')  {
		throw err
	}}
  }


  // installing react dev tools for this project
  // setting up debugging for this project
  const installExtensions = async () => {
//	const forceDownload = !!process.env.UPGRADE_EXTENSIONS;
	const extensions = ['REACT_DEVELOPER_TOOLS'];
  installExtension(extensions).then((name) => console.log(`Added Extension: ${name}`))
  .catch((err) => console.log(`An error occurred: ${err} `));
  
};


/* INIT */

ipcMain.handle('init', async(event, arg) => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg));

  console.log("\n HERE IS THE PATH: " + aPath)
  const Agent = new BackAgent(aPath);
  let json;
   try{
    const Employees : EmployeesModel | [] | DbResult = Agent.GetEmployees();
    const Departments : DepartmentsModel | DbResult | [] = Agent.GetDepartments();
      try {
        // FIRST ERROR EXPECTED
        const jsonFile :string = fs.readFileSync(path.join(app.getPath('userData'), 'db', (arg.split('.')[0]+'.json')), 'utf-8');
        json = JSON.parse(jsonFile);
      }
      catch(err) {
        // CREATE THE JSON
        const Jsonsuccess = CreateSettingsJSON(arg.split('.')[0]);
        const jsonFile :string = fs.readFileSync(path.join(app.getPath('userData'), 'db', (arg.split('.')[0]+'.json')),'utf-8');
        json = JSON.parse(jsonFile);
      }

    if (Array.isArray(Employees) && Array.isArray(Departments)) {
      let SettingsJson = {payPeriodStartDate: json?.payPeriodStartDate, rounding: json?.rounding}
      const InitData : InitModel = {Departments : Departments, Employees : Employees, SettingsJson}
      return InitData;
    }
   
   }
   catch(err) {
     console.log('ERROR AT init index.ts' +err);
      return {success: false, message:`failed at ipcMain init ${err}`}
   }
});


/*LANDING PAGE*/
import {
  GetDBs,
  CreateDB,
  DeleteDB,
  RenameDB,
 
} from './Main/Controllers/LandingController';
import EmployeesModel, { EmployeeModel } from './Render/Models/EmployeeModel';
import DbSingleResult from './Render/Models/DbSingleResult';
import DepartmentsModel, {DepartmentModel} from './Render/Models/DepartmentModel';
import { InitModel } from './Render/Models/InitModel';
import {ShiftModel} from './Render/Models/ShiftModel'

ipcMain.handle('asynchronous-get-DBs', async (event, arg) => {
    let dbs: string[] | NodeJS.ErrnoException = [];
    dbs = await GetDBs();	
    const waiting = await SimLoading();
    return dbs;
});

ipcMain.handle('create-db',  async (event, arg) => {
  const jsonSuccess = CreateSettingsJSON(arg);
  const success = await CreateDB(arg);
  return success && jsonSuccess
});

ipcMain.handle('delete-db', async (event, arg) => {
  const success = await DeleteDB(arg);
  const jsonSuccess = EditSettingsJSON(arg, 'delete', null);
  return success && jsonSuccess;
});

ipcMain.handle('rename-db', async(event, arg) => {
  const success = await RenameDB(arg);
  const jsonSuccess = EditSettingsJSON(arg[0],  'rename', arg[1]);
  return success && jsonSuccess;
});

/* EDIT THE SETTINGS */
// param
// SettingsJson: SettingsJsonModel

// ',{dbName, SettingsJson})

ipcMain.handle('change-settings', async(event, arg) =>  {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName.split(".")[0]+'.json'));

  try {
  const jsonSuccess = ChangeSettingsJSON(aPath, arg.SettingsJson);
  
  return {success: jsonSuccess, message: 'successfully changed the settings'};
  } catch(err) {
    console.log("ERR @ change-settings: "+ err);
    return {success: false, message: 'failed to change the settings'};
  }

});

/* ADD/REMOVE Page */

ipcMain.handle('add-employee', (event, arg : {dbName : string, Employee: EmployeeModel}) : DbSingleResult => {

  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);

  try {
    const result : DbSingleResult = Agent.AddEmployee(arg.Employee);
    Agent.CloseDB();
    return result;
  }
  catch (err) {
    console.log(`add-employee failed \n ${err}`)
    Agent.CloseDB();
    return {success: false, message: `Failed to add-employee`, rowId: 0};
  }
});


ipcMain.handle('edit-employee', (event, arg : {dbName : string, Employee: EmployeeModel}) : DbSingleResult => {

  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);
  try {
    const result : DbSingleResult = Agent.EditEmployee(arg.Employee);
    Agent.CloseDB();
    return result;
  }
  catch (err) {
    console.log(`edit-employee failed \n ${err}`)
    Agent.CloseDB();
    return {success: false, message: `Failed to edit-employee`, rowId: 0};
  }
});

ipcMain.handle('delete-employee', (event, arg: {dbName: string, Employee: EmployeeModel}) : DbSingleResult => {

  // refactor to make this path easier?
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);
  try {
    const result : DbSingleResult = Agent.DeleteEmployee(arg.Employee);
    Agent.CloseDB();
    return result;
  }
  catch (err) {
    console.log(`delete-employee failed \n ${err}`);
    Agent.CloseDB();
    return {success: false, message: "Failed to delete the emplyee", rowId: 0};
  }
});

ipcMain.handle('add-department', (event, arg: {dbName: string, Department: DepartmentModel}) : DbSingleResult => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);
  try {
    const result: DbSingleResult = Agent.AddDepartment(arg.Department);
    Agent.CloseDB();
    return result;
  }
  catch (err) {
    console.log(`delete-employee failed \n ${err}`);
    Agent.CloseDB();
    return {success: false, message: "Failed to add a department", rowId: 0};
  }
});


ipcMain.handle('edit-department', (event, arg: {dbName: string, Department: DepartmentModel}) : DbSingleResult => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);
  try {
    const result: DbSingleResult = Agent.EditDepartment(arg.Department);
    Agent.CloseDB();
    return result;
  }
  catch (err) {
    console.log(`delete-employee failed \n ${err}`);
    Agent.CloseDB();
    return {success: false, message: "Failed to add a department", rowId: 0};
  }
});


ipcMain.handle('delete-department', (event, arg: {dbName: string, Department: DepartmentModel}) : DbSingleResult => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);
  try {
    const result: DbSingleResult = Agent.DeleteDepartment(arg.Department);
    Agent.CloseDB();
    return result;
  }
  catch (err) {
    console.log(`delete-department failed \n ${err}`);
    Agent.CloseDB();
    return {success: false, message: "Failed to delete the department", rowId: 0};
  }
});


ipcMain.handle('add-shift', (event, arg: {dbName: string, Shift: ShiftModel}) : DbSingleResult => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);
  try {
    const result: DbSingleResult = Agent.AddShift(arg.Shift)
    Agent.CloseDB();
    return result;
  }
  catch (err) {
    Agent.CloseDB();
    return {success: false, message: "Failed to add shift", rowId: 0};
  }
})
// GetSingleShifts(start: string, end:string, employeeId: number): Result<ShiftModel[]> {
ipcMain.handle('get-single-shifts', (event, arg: {dbName: string, StartDate: string, EndDate: string, EmployeeId: number}): ApiResult<ShiftModel[]> => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);

  try {
    const result: Result<ShiftModel[]> = Agent.GetSingleShifts(arg.StartDate, arg.EndDate, arg.EmployeeId);
    const theShifts = new ApiResult<ShiftModel[]>(true, [], result.getValue());
  
    Agent.CloseDB();
    return theShifts;
  }
  catch (err) {
    Agent.CloseDB();
    console.log(`get-single-shifts failed \n ${err} `);
   // const result: Result<ShiftModel[]> = Result.fail([err]);
    const result: ApiResult<ShiftModel[]> = new ApiResult<any>(false, [err], []);
    return result;
  }
});

ipcMain.handle('edit-shift', (event, arg: {dbName: string, Shift: ShiftModel}): DbSingleResult => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);

  try {
    const result: DbSingleResult = Agent.EditShift(arg.Shift);
    Agent.CloseDB();
    return result;
  } 
  catch(err) {
    Agent.CloseDB();
    console.log(`edit-shift failed \n ${err}`);
    const result = {rowId: 0, success: false, message: err}
    return result;
  }
});


ipcMain.handle('delete-shift', (event, arg: {dbName: string, ShiftId: number}): DbSingleResult => {
  console.log("\n \n THE DB NAME IS : "+ arg.dbName);

  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);

  try {
    const result: DbSingleResult = Agent.DeleteShift(arg.ShiftId);
    Agent.CloseDB();
    return result;
  }

  catch(err) {
    Agent.CloseDB();
    console.log(`delete-shift failed \n ${err}`);
    return {rowId: 0, success: false, message: err};
  }
});


ipcMain.handle('get-summary-shifts', (event, arg: {dbName: string, Start:string, End: string, Department: string, DepartmentId: number }):  ApiResult<SummaryShift[]> => {
  const aPath = path.join(app.getPath('userData'), 'db', (arg.dbName));
  const Agent = new BackAgent(aPath);
  const {Start, End, Department, DepartmentId} = arg;
  try {
    const result: Result<SummaryShift[]> = Agent.GetSummaryShifts(Start, End, Department, DepartmentId);
    Agent.CloseDB();
    return new ApiResult<SummaryShift[]>(true, [], result.getValue());
  }

  catch(err) {
    Agent.CloseDB();
    console.log(`get-single-shifts failed \n ${err} `);
    const result: ApiResult<SummaryShift[]> = new ApiResult<any>(false, [err], []);
    return result;
  }
});

ipcMain.handle('download', (event, arg: {SummaryObject: SummaryObject, format: string, start: string, end: string}) => {
 
  const fileName  =  `Shift_Report_${moment().format('MM_DD')}.${arg.format}`

  const options = {
    title: "Save shift summary",
    defaultPath: 'documents/' +fileName,
    buttonLabel: 'save',
    filters: [
     {name: 'comma separated value', extensions: ["csv"]},
    ]
  }

  const result = dialog.showSaveDialogSync(null, options)

  if (result === undefined) {
    return {success:false, message: "Cancelled"}
    // respond with an error message
    // turn it into a modal error with the error
    // try catch with the error
  }
  let reportString = `Date range, ${arg.start}, ${arg.end} \n Employee,Reg Hours,Overtime,Total \n`;
  for (const key in arg.SummaryObject) {
   reportString += `${arg.SummaryObject[key].Name},${getHoursMinutes(arg.SummaryObject[key].RegHours)},${getHoursMinutes(arg.SummaryObject[key].OvertimeInMinutes)},${getHoursMinutes(arg.SummaryObject[key].Total)} \n`
  }

  fs.writeFile(result, reportString, function (err) {
    if (err) return {success: false, message: err}
  });

  return {success:true, message: "Successfully downloaded the report"}
})